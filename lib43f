#!/usr/bin/env bash

# find using extended regular expressions
function Efind() {
	local path="$1"
	shift
	local regex="$1"
	shift
	case "$(uname)" in
		Darwin)
			find -E "$path" -regex "$regex" "$@"
			;;
		Linux)
			find "$path" -regextype posix-extended -regex "$regex" "$@"
			;;
		OpenBSD)
			find "$path" "$@" | grep -E "$regex"
			;;
	esac
}

# sed using extended regular expressions
function Esed() {
	case "$(uname)" in
		Darwin|OpenBSD)
			sed -E "$@"
			;;
		Linux)
			sed -r "$@"
			;;
	esac
}

# calculate relative dates
function reldate() {
	local adjust="$1"
	local format="$2"

	case "$(uname)" in
		Darwin)
			date -v"${adjust}" "$format"
			;;
		Linux)
			# convert BSD style adjustment to GNU style string
			if [[ "$adjust" =~ ^([+-]?[0-9]+)([ymwdHMS])$ ]]; then
				case "${BASH_REMATCH[2]}" in
					y)
						adjust="${BASH_REMATCH[1]} years"
						;;
					m)
						adjust="${BASH_REMATCH[1]} months"
						;;
					w)
						adjust="${BASH_REMATCH[1]} weeks"
						;;
					d)
						adjust="${BASH_REMATCH[1]} days"
						;;
					H)
						adjust="${BASH_REMATCH[1]} hours"
						;;
					M)
						adjust="${BASH_REMATCH[1]} minutes"
						;;
					S)
						adjust="${BASH_REMATCH[1]} seconds"
						;;
				esac
			fi
			date -d "$adjust" "$format"
			;;
		OpenBSD)
			dadd -f "${format#+}" "$(date "+%Y-%m-%d %H:%M:%S")" "$adjust"
			;;
	esac
}

# convert a date format string to a regular expression
function parse_date_format_value() {
	local success=true
	local in_format="$1"
	local in_date="$2"
	local parse_sequence="$3"
	local match_format="$in_format"

	# build a regular expression based on the date format
	# replace %Y with four digit year match
	if [ "$parse_sequence" = "%Y" ]; then
		match_format=$(echo -n "$match_format" | Esed "s/%Y/([0-9]{4})/g")
	else
		match_format=$(echo -n "$match_format" | Esed "s/%Y/[0-9]{4}/g")
	fi
	# replace %m with two digit month match
	if [ "$parse_sequence" = "%m" ]; then
		match_format=$(echo -n "$match_format" | Esed "s/%m/(0[123456789]|1[012])/g")
	else
		match_format=$(echo -n "$match_format" | Esed "s/%m/(?:0[123456789]|1[012])/g")
	fi
	# replace %d with two digit day match
	if [ "$parse_sequence" = "%d" ]; then
		match_format=$(echo -n "$match_format" | Esed "s/%d/(0[123456789]|[12][0-9]|3[01])/g")
	else
		match_format=$(echo -n "$match_format" | Esed "s/%d/(?:0[123456789]|[12][0-9]|3[01])/g")
	fi
	# replace %H with two digit hour match
	if [ "$parse_sequence" = "%H" ]; then
		match_format=$(echo -n "$match_format" | Esed "s/%H/([01][0-9]|2[0123])/g")
	else
		match_format=$(echo -n "$match_format" | Esed "s/%H/(?:[01][0-9]|2[0123])/g")
	fi
	# replace %M with two digit minute match
	if [ "$parse_sequence" = "%M" ]; then
		match_format=$(echo -n "$match_format" | Esed "s/%M/([012345][0-9])/g")
	else
		match_format=$(echo -n "$match_format" | Esed "s/%M/[012345][0-9]/g")
	fi
	# replace %S with two digit seconds match
	if [ "$parse_sequence" = "%S" ]; then
		match_format=$(echo -n "$match_format" | Esed "s/%M/([012345][0-9])/g")
	else
		match_format=$(echo -n "$match_format" | Esed "s/%M/[012345][0-9]/g")
	fi
	# replace %% with a single % (this should always be done last)
	match_format=$(echo -n "$match_format" | Esed "s/%%/%/g")

	# use the regex to parse the sequence out of the actual date (use grep with PCRE as we need to use non-capturing groups)
	local parsed_sequence="$(perl -pe "s/${match_format}/\1/g" <<< "$in_date")"
	if [ $? -eq 0 ]; then
		echo -n "$parsed_sequence"
	else
		success=false
	fi

	$success;
}

# convert date strings
function convdatestr() {
	local in_format="$1"
	local in_date="$2"
	local out_format="$3"

	case "$(uname)" in
		Darwin|OpenBSD)
			date -j -f "$in_format" "$in_date" "$out_format"
			;;
		Linux)
			local has_year=false
			local has_month=false
			local has_day=false
			local has_hour=false
			local has_minute=false
			local has_second=false
			local year
			local month
			local day
			local hour
			local minute
			local second
			local tmp_date

			# parse out custom date
			if [[ "$in_format" =~ "%Y" ]]; then
				has_year=true
				year="$(parse_date_format_value "$in_format" "$in_date" "%Y")"
			fi
			if [[ "$in_format" =~ "%m" ]]; then
				has_month=true
				month="$(parse_date_format_value "$in_format" "$in_date" "%m")"
			fi
			if [[ "$in_format" =~ "%d" ]]; then
				has_day=true
				day="$(parse_date_format_value "$in_format" "$in_date" "%d")"
			fi
			if [[ "$in_format" =~ "%H" ]]; then
				has_hour=true
				hour="$(parse_date_format_value "$in_format" "$in_date" "%H")"
			fi
			if [[ "$in_format" =~ "%M" ]]; then
				has_minute=true
				minute="$(parse_date_format_value "$in_format" "$in_date" "%M")"
			fi
			if [[ "$in_format" =~ "%S" ]]; then
				has_second=true
				second="$(parse_date_format_value "$in_format" "$in_date" "%S")"
			fi

			# output the date into an intermediary format that Linux's date command understands
			if $has_year && $has_month && $has_day; then
				tmp_date="${year}-${month}-${day}"
			fi
			if $has_hour && $has_minute; then
				tmp_date="${tmp_date} ${hour}:${minute}"
				if $has_second; then
					tmp_date="${tmp_date}:${second}"
				fi
			fi

			date -d "$tmp_date" "$out_format"
			;;
	esac
}
